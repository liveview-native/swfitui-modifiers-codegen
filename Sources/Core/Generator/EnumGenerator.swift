import Foundation
import SwiftSyntaxBuilder
import SwiftSyntax

/// Generates type-safe Swift enum code for modifiers.
///
/// This generator creates enum cases for each modifier variant,
/// along with helper methods for applying modifiers to views.
public struct EnumGenerator: Sendable {
    /// Errors that can occur during code generation.
    public enum GenerationError: Error, Equatable {
        case invalidModifierInfo(String)
        case unsupportedType(String)
        case codeGenerationFailed(String)
    }
    
    /// Creates a new enum generator.
    public init() {}
    
    /// Generates an enum definition for a group of related modifiers.
    ///
    /// - Parameters:
    ///   - enumName: The name of the enum to generate.
    ///   - modifiers: The modifiers to include in the enum.
    /// - Returns: A GeneratedCode instance containing the generated enum.
    /// - Throws: GenerationError if the code cannot be generated.
    public func generate(enumName: String, modifiers: [ModifierInfo]) throws -> GeneratedCode {
        guard !modifiers.isEmpty else {
            throw GenerationError.invalidModifierInfo("Cannot generate enum with no modifiers")
        }
        
        var warnings: [String] = []
        var generatedCases: [String] = []
        
        // Generate enum cases
        for modifier in modifiers {
            let enumCase = try generateEnumCase(for: modifier)
            generatedCases.append(enumCase)
        }
        
        // Build complete enum
        let sourceCode = buildEnumSource(
            enumName: enumName,
            cases: generatedCases,
            modifiers: modifiers
        )
        
        return GeneratedCode(
            sourceCode: sourceCode,
            fileName: "\(enumName).swift",
            modifierCount: modifiers.count,
            warnings: warnings
        )
    }
    
    // MARK: - Private Generation Methods
    
    /// Generates an enum case for a single modifier.
    private func generateEnumCase(for modifier: ModifierInfo) throws -> String {
        let caseName = makeCaseName(from: modifier.name)
        
        if modifier.parameters.isEmpty {
            // Simple case with no associated values
            return "case \(caseName)"
        }
        
        // Case with associated values
        let params = modifier.parameters.map { param -> String in
            let type = param.type
            if let label = param.label {
                return "\(label): \(type)"
            } else {
                return type
            }
        }.joined(separator: ", ")
        
        return "case \(caseName)(\(params))"
    }
    
    /// Builds the complete enum source code.
    private func buildEnumSource(
        enumName: String,
        cases: [String],
        modifiers: [ModifierInfo]
    ) -> String {
        var lines: [String] = []
        
        // Header comment
        lines.append("/// Generated modifier enum for \(enumName) modifiers.")
        lines.append("///")
        lines.append("/// This enum provides type-safe access to SwiftUI view modifiers.")
        lines.append("/// Generated by ModifierSwift.")
        
        // Enum declaration
        lines.append("public enum \(enumName): Equatable, Sendable {")
        
        // Add cases
        for caseStr in cases {
            lines.append("    \(caseStr)")
        }
        
        lines.append("}")
        
        // Extension with apply method
        lines.append("")
        lines.append("extension View {")
        lines.append("    /// Applies a \(enumName) modifier to this view.")
        lines.append("    ///")
        lines.append("    /// - Parameter modifier: The modifier to apply.")
        lines.append("    /// - Returns: A modified view.")
        lines.append("    @inlinable")
        lines.append("    public func modifier(_ modifier: \(enumName)) -> some View {")
        lines.append("        switch modifier {")
        
        // Generate switch cases
        for modifier in modifiers {
            let caseName = makeCaseName(from: modifier.name)
            let switchCase = generateSwitchCase(for: modifier, caseName: caseName)
            lines.append("        \(switchCase)")
        }
        
        lines.append("        }")
        lines.append("    }")
        lines.append("}")
        
        return lines.joined(separator: "\n")
    }
    
    /// Generates a switch case for applying a modifier.
    private func generateSwitchCase(for modifier: ModifierInfo, caseName: String) -> String {
        if modifier.parameters.isEmpty {
            return "case .\(caseName):\n            self.\(modifier.name)()"
        }
        
        // Build pattern and call
        let pattern = modifier.parameters.enumerated().map { index, param -> String in
            if let label = param.label {
                return "let \(label)"
            } else {
                return "let param\(index)"
            }
        }.joined(separator: ", ")
        
        let call = modifier.parameters.enumerated().map { index, param -> String in
            let value: String
            if let label = param.label {
                value = label
            } else {
                value = "param\(index)"
            }
            
            if let paramLabel = param.label {
                return "\(paramLabel): \(value)"
            } else {
                return value
            }
        }.joined(separator: ", ")
        
        return "case .\(caseName)(\(pattern)):\n            self.\(modifier.name)(\(call))"
    }
    
    /// Creates a valid Swift enum case name from a modifier name.
    private func makeCaseName(from modifierName: String) -> String {
        // Remove special characters and convert to camelCase
        var name = modifierName
        
        // Handle leading underscores
        if name.hasPrefix("_") {
            name = "underscore" + name.dropFirst()
        }
        
        // Ensure first character is lowercase
        if let first = name.first {
            name = first.lowercased() + name.dropFirst()
        }
        
        return name
    }
}

